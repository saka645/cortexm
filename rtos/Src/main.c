/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#define TASK_NUMBER_MAX   (16)
#define RAM_START         (0x20000000u)
#define RAM_SIZE          (8 * 1024) // 8 KB

#define MAIN_STACK        (RAM_START + RAM_SIZE)
#define TASK_STACK_SIZE   (1024u)

/* SysTick register address */
#define SCSR                  *((volatile uint32_t*) 0xE000E010u)
#define SRVR                  *((volatile uint32_t*) 0xE000E014u)
#define SYSTICK_RELOAD_REG			0xE000E014U
#define HSI_FREQ					8000000U//8MHZ
#define TICK_HZ						1000U

uint32_t __uCurrentTaskIdx = 0;
uint32_t __puTasksPSP[TASK_NUMBER_MAX] = {0};

void task1_main(void *param) {

    // main loop
    while(1) {
        // do things over and over
    }
}

void task2_main(void *param) {

    // main loop
    while(1) {
        // do things over and over
    }
}

void task3_main(void *param) {

    // main loop
    while(1) {
        // do things over and over
    }
}

void task4_main(void *param) {

    // main loop
    while(1) {
        // do things over and over
    }
}

void start_scheduler() {

	uint32_t *pSRVR = (uint32_t *)SYSTICK_RELOAD_REG;
	uint32_t *pCTR = (uint32_t *)0xE000E010;
	uint32_t count = HSI_FREQ/TICK_HZ;
	/*clear rvr*/
	*pSRVR &= ~(0x00FFFFFF);
	//LOAD THE VALUE//
	*pSRVR = count-1;
	/*enable counter*/
	*pCTR |= 0x07;
  //printf("Start Scheduler!\n");

  // start with the first task
  __uCurrentTaskIdx = 0;

  // prepare PSP of the first task
  __asm volatile("BL get_current_psp"); // return PSP in R0
  __asm volatile("MSR PSP, R3");  // set PSP

  // change to use PSP
  __asm volatile("MRS R0, CONTROL");
  __asm volatile("MOVS R1,#2"); // set bit[1] SPSEL
  __asm volatile("ORR R0, R0, R1");


  __asm volatile("MSR CONTROL, R0");

  // get the handler of the first task by tracing back from PSP which is at R4 slot
  void (*handler)() = (void (*))((uint32_t*)__puTasksPSP[__uCurrentTaskIdx])[14];

  // execute the handler
  handler();
}




// return PSP value stored in slot at __uCurrentTaskIdx index
uint32_t get_current_psp() {
  return __puTasksPSP[__uCurrentTaskIdx];
}

// save PSP value to the slot at __uCurrentTaskIdx index
void save_current_psp(uint32_t psp) {
  __puTasksPSP[__uCurrentTaskIdx] = psp;
}

void init_task(void (*handler)) {
	int i=0;

	  // find an empty slot
	  for(; i<TASK_NUMBER_MAX; i++) {
	    if (__puTasksPSP[i] == 0) break;
	  }

	  if(i >= TASK_NUMBER_MAX) {
	    //printf("Can not register a new task anymore!\n");
	    return;
	  } else {
	    //printf("Register a task %p at slot %i\n", handler, i);
	  }

	  // calculate new PSP
	  uint32_t* psp = (uint32_t*)(MAIN_STACK - (i+1)*TASK_STACK_SIZE);
    // fill dummy stack frame
    *(--psp) = 0x01000000u; // Dummy xPSR, just enable Thumb State bit;
    *(--psp) = (uint32_t) handler; // PC
    *(--psp) = 0xFFFFFFFDu; // LR with EXC_RETURN to return to Thread using PSP
    *(--psp) = 0x12121212u; // Dummy R12
    *(--psp) = 0x03030303u; // Dummy R3
    *(--psp) = 0x02020202u; // Dummy R2
    *(--psp) = 0x01010101u; // Dummy R1
    *(--psp) = 0x00000000u; // Dummy R0
    *(--psp) = 0x11111111u; // Dummy R11
    *(--psp) = 0x10101010u; // Dummy R10
    *(--psp) = 0x09090909u; // Dummy R9
    *(--psp) = 0x08080808u; // Dummy R8
    *(--psp) = 0x07070707u; // Dummy R7
    *(--psp) = 0x06060606u; // Dummy R6
    *(--psp) = 0x05050505u; // Dummy R5
    *(--psp) = 0x04040404u; // Dummy R4

    // save PSP
    __puTasksPSP[i] = (uint32_t)psp;
}

void select_next_task() {
    /* Round-Robin scheduler */
    __uCurrentTaskIdx++;
    // check if a task is register at current slot
    if (__uCurrentTaskIdx >= TASK_NUMBER_MAX || __puTasksPSP[__uCurrentTaskIdx] == 0) {
        __uCurrentTaskIdx=0;
    }
}

__attribute__ ((naked)) void SysTick_Handler() {
	// Save LR to main (manually handle stack on M0)
	__asm volatile("MOV R0, LR");  // Move LR to R0
	__asm volatile("PUSH {R0}");   // Push R0 (which holds LR) onto the stack


	// Print
	//printf("****\n");

	/* Save the context of the current task */

	// Get current PSP
	__asm volatile("MRS R0, PSP");

	// Save R4 to R7
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R4, [R0]");
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R5, [R0]");
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R6, [R0]");
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R7, [R0]");

	// Manually save R8 to R11
	__asm volatile("MOV R1, R8");
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R1, [R0]");
	__asm volatile("MOV R1, R9");
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R1, [R0]");
	__asm volatile("MOV R1, R10");
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R1, [R0]");
	__asm volatile("MOV R1, R11");
	__asm volatile("SUB R0, R0, #4");
	__asm volatile("STR R1, [R0]");

	// Save current value of PSP
	__asm volatile("BL save_current_psp"); // R0 is the first argument

	/* Do scheduling */

	// Select next task
	__asm volatile("BL select_next_task");

	/* Retrieve the context of the next task */

	// Get its previous PSP value
	__asm volatile("BL get_current_psp"); // return PSP is in R0

	// Restore R8 to R11 from PSP Frame Stack
	__asm volatile("LDR R1, [R0]");
	__asm volatile("ADD R0, R0, #4");
	__asm volatile("MOV R8, R1");
	__asm volatile("LDR R1, [R0]");
	__asm volatile("ADD R0, R0, #4");
	__asm volatile("MOV R9, R1");
	__asm volatile("LDR R1, [R0]");
	__asm volatile("ADD R0, R0, #4");
	__asm volatile("MOV R10, R1");
	__asm volatile("LDR R1, [R0]");
	__asm volatile("ADD R0, R0, #4");
	__asm volatile("MOV R11, R1");

	// Restore R4 to R7
	__asm volatile("LDR R4, [R0]");
	__asm volatile("ADD R0, R0, #4");
	__asm volatile("LDR R5, [R0]");
	__asm volatile("ADD R0, R0, #4");
	__asm volatile("LDR R6, [R0]");
	__asm volatile("ADD R0, R0, #4");
	__asm volatile("LDR R7, [R0]");
	__asm volatile("ADD R0, R0, #4");

	// Update PSP
	__asm volatile("MSR PSP, R0");

	// Exit
	__asm volatile("POP {R3}");
	__asm volatile("MOV LR, R3");
	__asm volatile("BX LR");


}


int main(void)
{
    // add tasks
    init_task(task1_main);
    init_task(task2_main);
    init_task(task3_main);
    init_task(task4_main);
    // start
    start_scheduler();
    // should never go here
    /* Loop forever */
	for(;;);
}
