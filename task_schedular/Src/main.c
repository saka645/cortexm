/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif



void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
int seconds = 0, miliSeconds=0;
uint32_t psp_of_tasks[MAX_TASKS]={T1_STACK_START,T2_STACK_START,T3_STACK_START,T4_STACK_START};
uint32_t task_handlers[MAX_TASKS];
int current_task = 0;
void systick_init(uint32_t tick);
void init_tasks_stack();
void enable_processor_faults();
__attribute__((nacked)) void switch_sp_to_psp();
uint32_t getCurrentPsp();

__attribute__((nacked)) void init_schedular_stack(uint32_t);
int main(void)
{
	enable_processor_faults();

	init_schedular_stack(SCHED_STACK_START);
	task_handlers[0] = (uint32_t *)task1_handler;
	task_handlers[1] = (uint32_t *)task2_handler;
	task_handlers[2] = (uint32_t *)task3_handler;
	task_handlers[3] = (uint32_t *)task4_handler;
	init_tasks_stack();
	systick_init(TICK_HZ); //100hz or 1ms

	switch_sp_to_psp();
	task1_handler();
    /* Loop forever */
	for(;;);
}



void task1_handler(void)
{
	while(1);
}

void task2_handler(void)
{
	while(1);
}

void task3_handler(void)
{
	while(1);
}

void task4_handler(void)
{
	while(1);
}

void systick_init(uint32_t tick)
{
	uint32_t *pSRVR = (uint32_t *)SYSTICK_RELOAD_REG;
	uint32_t *pCTR = (uint32_t *)0xE000E010;
	uint32_t count = HSI_FREQ/tick;
	/*clear rvr*/
	*pSRVR &= ~(0x00FFFFFF);
	//LOAD THE VALUE//
	*pSRVR = count-1;
	/*enable counter*/
	*pCTR |= 0x07;


}
void save_psp_value(uint32_t addr)
{
	psp_of_tasks[current_task] = addr;
}
void update_next_task()
{
	current_task++;
	current_task = current_task % MAX_TASKS;
}
void SysTick_Handler(void)
{
//	if(miliSeconds++>=1000)
//	{
//		miliSeconds = 0;
//		seconds++;
//	}
	/*save the context of current task*/
	//1.get current runnint task psp value
	__asm volatile("MRS R0, PSP");

	//2.STORE SF2
	__asm volatile("STMDB R0!, {R4-R14}");

	//3.SAVE CURRENT VALUE OF PSP
	__asm volatile("BL save_psp_value");


	/*retrivate context of next task*/

	//1.DECIDE NEXT TASK TO RUN
	__asm volatile("BL update_next_task");

	//2.GET ITS PAST PSP VALUE
	__asm volatile("BL getCurrentPsp");

	//3.RETRIVE SF2 USING PSP VALUE
	__asm volatile("LDMIA R0!, {R4-R14}");

	//4.UPDATE PSP AND EXIT
	__asm volatile("MSR PSP, R0");
}

__attribute__((nacked)) void init_schedular_stack(uint32_t sched_top_of_stack)
{
	__asm volatile("MSR MSP, R0");//MSP = sched_top_of_stack
	__asm volatile("BX LR");//PC = LR
}

void init_tasks_stack()
{
	uint32_t *pPSP;
	for(int i=0; i<MAX_TASKS; i++)
	{
		pPSP = (uint32_t *)psp_of_tasks[i];
		pPSP--;
		*pPSP = DUMMY_XPSR;//0x00100000

		pPSP--;//pc
		*pPSP = task_handlers[i];

		pPSP--;//lr
		*pPSP = 0xfdffffff;




		for(int j=0; j<13; j++)
		{
			pPSP--;
			*pPSP = 0;
		}
		psp_of_tasks[i] = (uint32_t)pPSP;

	}
}


void enable_processor_faults()
{


}
__attribute__((nacked)) void switch_sp_to_psp()
{
	//initialize psp with task1 start
	__asm volatile("push {LR}");
	__asm volatile("BL getCurrentPsp");
	__asm volatile("MSR PSP,R0");//GET psp from r0 to psp

	__asm volatile("pop {LR}");

	//change sp to psp
	__asm volatile("MOV R0,#0X02");
	__asm volatile("MSR CONTROL,R0");

	__asm volatile("BX LR");//GO BACK TO MAIN
}
uint32_t getCurrentPsp()
{
	return psp_of_tasks[current_task];
}
